# Story 2.4: Ultra-Simple Member Management

<!-- Powered by BMAD‚Ñ¢ Core -->

## Status
Draft

## Story

**As a** library staff member,  
**I want** to register new library members with basic contact information,  
**so that** I can track who can borrow books without complex member management workflows.

## Acceptance Criteria

1. Simple member registration form: name, email, basic contact information only
2. Automatic member ID generation (simple auto-increment format)
3. Basic member search by name and email only
4. Simple member list showing name, email, and current checkout count
5. Basic member profile showing contact information and list of currently checked-out books
6. Edit member contact information with email format validation
7. All members default to "active" status - no complex status management initially
8. Duplicate detection by email address to prevent multiple accounts
9. No advanced features like fines, limits, or communication preferences in initial version

## Tasks / Subtasks

**üìù EXECUTION ORDER**: Tasks must be completed sequentially (1‚Üí2‚Üí3‚Üí4‚Üí5‚Üí6‚Üí7) due to component dependencies

### **Task 1: Create Member List Page Route and Layout** (AC: 3, 4, 7)
*Covers: Member list display, basic search, status management*
- [ ] Create `src/app/[library-code]/members/page.tsx` following Next.js 15 App Router patterns
- [ ] Implement library context integration for scoped member operations
- [ ] Add responsive layout with mobile-first design using Tailwind CSS
- [ ] Create member list display with name, email, and current checkout count
- [ ] Implement basic search functionality by name and email with real-time filtering
- [ ] Add pagination for member lists (support up to 1,000 members per Epic 2 requirements)
- [ ] Include "Add New Member" button prominently displayed for easy access

### **Task 2: Build Member Registration Form Component** (AC: 1, 2, 7, 8)
*Covers: Registration form, automatic ID generation, duplicate detection*
- [ ] Create `src/app/[library-code]/members/add/page.tsx` following Next.js 15 App Router patterns  
- [ ] Create `src/components/members/add-member-form.tsx` with comprehensive form validation
- [ ] Implement member registration form with name, email, phone, and address fields
- [ ] Add automatic member ID generation (simple auto-increment format per library)
- [ ] Implement duplicate detection by email address with clear error messaging
- [ ] Add form validation with Zod schema for member registration
- [ ] Set all new members to "active" status by default
- [ ] Include success notification with option to "Add Another Member"

### **Task 3: Build Member Profile Display Component** (AC: 5, 7)
*Covers: Member profile view, checkout history, contact display*
- [ ] Create `src/app/[library-code]/members/[id]/page.tsx` following Next.js 15 App Router patterns
- [ ] Create `src/components/members/member-profile.tsx` with comprehensive display
- [ ] Implement member profile showing all contact information and membership details
- [ ] Add list of currently checked-out books with book titles and checkout dates
- [ ] Create member status display with visual indicators for active/inactive states
- [ ] Add breadcrumb navigation integration with existing member list page
- [ ] Implement 404 error page for non-existent members

### **Task 4: Build Member Edit Form Component** (AC: 6, 7, 8)
*Covers: Contact information editing, email validation, duplicate prevention*
- [ ] Create `src/app/[library-code]/members/[id]/edit/page.tsx` following Next.js 15 App Router patterns
- [ ] Create `src/components/members/edit-member-form.tsx` with field validation
- [ ] Implement editable fields: name, email, phone, address
- [ ] Add email format validation with proper error messaging
- [ ] Implement duplicate email detection during edit operations
- [ ] Add form validation with Zod schema for member updates
- [ ] Include member status management (active/inactive only for simplicity)
- [ ] Add role validation for edit operations (librarian+ only)

### **Task 5: Implement Database Integration APIs** (AC: 1-9)
*Covers: Member queries, creation, updates, search functionality*
- [ ] Create member API functions in `src/lib/api/members.ts` with full CRUD operations
- [ ] Implement member registration API with automatic member ID generation
- [ ] Create member search API with name and email filtering capabilities
- [ ] Add member profile API with joined checkout information
- [ ] Implement member update API with field validation and RLS compliance
- [ ] Add duplicate email checking API for registration and updates
- [ ] Ensure proper RLS policies and library context isolation
- [ ] Add error handling for database operations and constraint violations

### **Task 6: Implement Real-time Integration and State Management** (AC: 4, 5)
*Covers: TanStack Query integration, cache management, real-time updates*
- [ ] Create member hooks in `src/lib/hooks/use-members.ts` with TanStack Query integration
- [ ] Implement member list query with search and pagination capabilities
- [ ] Add member profile query with real-time checkout count updates
- [ ] Create member mutation hooks for add, edit, and status updates
- [ ] Implement query invalidation patterns for immediate UI updates
- [ ] Add optimistic updates for member operations where appropriate
- [ ] Include loading states and error handling for all member operations

### **Task 7: Testing Implementation** (AC: 1-9)
*Covers: Complete functionality validation, form validation, database operations*
- [ ] Create unit tests for member form components and validation schemas
- [ ] Add integration tests for member API functions and database operations
- [ ] Write E2E tests for complete add ‚Üí view ‚Üí edit member workflow
- [ ] Test duplicate email detection for both registration and edit operations
- [ ] Validate member search functionality with various search terms
- [ ] Test role-based access control for member management operations
- [ ] Verify member list pagination and performance with large datasets

## Dev Notes

### **Previous Story Context**

Based on completed Story 2.3 (Book Details and Management), we have established:

- Library context management system with RLS policies working effectively
- TanStack Query integration patterns for data fetching and mutations with proper cache invalidation
- React Hook Form with Zod validation schemas for form handling and validation
- Role-based access control patterns with permission system integration
- Mobile-responsive design with shadcn/ui components and Tailwind CSS
- Comprehensive error handling and loading state patterns
- Real-time updates and query invalidation strategies

### **Data Models and Database Schema**

[Source: docs/architecture/database-design.md]

**Library Members - Core Data Structure:**

The member management system uses the `library_members` table with the following schema:

```typescript
// Member Core Data - library_members table
interface LibraryMember {
  id: string;                    // Primary key UUID
  user_id?: string;              // Optional reference to auth.users(id), NULL for non-digital members
  library_id: string;            // References libraries(id)
  member_id: string;             // Library-specific identifier (e.g., "M001", "CARD-12345")
  personal_info: {               // JSONB: Contact and personal details
    first_name: string;
    last_name: string;
    email: string;
    phone?: string;
    address?: {
      street?: string;
      city?: string;
      state?: string;
      country?: string;
      postal_code?: string;
    };
  };
  membership_info: {             // JSONB: Membership details
    type: 'regular' | 'student' | 'senior';
    fees_owed: number;
    expiry_date?: string;
    notes?: string;
  };
  borrowing_stats: {             // JSONB: Cached borrowing statistics for performance
    current_loans: number;
    total_books_borrowed: number;
    overdue_items: number;
    total_late_fees: number;
  };
  status: 'active' | 'inactive' | 'banned';
  is_deleted: boolean;
  deleted_at?: string;
  deleted_by?: string;
  created_at: string;
  updated_at: string;
}
```

**Member ID Generation Pattern:**

```typescript
// Automatic member ID generation (simple auto-increment format)
const generateMemberID = async (libraryId: string): Promise<string> => {
  const { count } = await supabase
    .from("library_members")
    .select("id", { count: "exact", head: true })
    .eq("library_id", libraryId)
    .eq("is_deleted", false);
  
  const nextNumber = (count || 0) + 1;
  return `M${nextNumber.toString().padStart(3, '0')}`; // M001, M002, etc.
};
```

**Member Search and List Query Pattern:**

```typescript
// Member list with search and checkout count
const fetchMembers = async (libraryId: string, searchTerm?: string) => {
  let query = supabase
    .from("library_members")
    .select(`
      id,
      member_id,
      personal_info,
      membership_info,
      borrowing_stats,
      status,
      created_at,
      updated_at
    `)
    .eq("library_id", libraryId)
    .eq("is_deleted", false)
    .order("created_at", { ascending: false });

  if (searchTerm) {
    query = query.or(`
      personal_info->>first_name.ilike.%${searchTerm}%,
      personal_info->>last_name.ilike.%${searchTerm}%,
      personal_info->>email.ilike.%${searchTerm}%,
      member_id.ilike.%${searchTerm}%
    `);
  }

  return query;
};
```

**Duplicate Email Detection Pattern:**

```typescript
// Check for duplicate email within library
const checkDuplicateEmail = async (
  libraryId: string, 
  email: string, 
  excludeMemberId?: string
): Promise<boolean> => {
  let query = supabase
    .from("library_members")
    .select("id")
    .eq("library_id", libraryId)
    .eq("personal_info->>email", email)
    .eq("is_deleted", false);

  if (excludeMemberId) {
    query = query.neq("id", excludeMemberId);
  }

  const { data } = await query.single();
  return !!data;
};
```

### **Component Architecture Patterns**

[Source: docs/architecture/tech-stack.md, docs/architecture/coding-standards.md]

**Required Tech Stack for Member Management:**

- **React Hook Form 7.62.0** with form state management for all member forms
- **Zod 4.1.3** for member data validation schemas and email format validation
- **TanStack Query 5.85.5** for data fetching, caching, and mutation operations
- **shadcn/ui Components** for consistent UI design (Card, Button, Input, Select, Dialog)
- **Lucide React 0.542.0** for user profile, edit, search, and status icons

**Member Component Architecture Pattern:**

```typescript
// src/components/members/member-profile.tsx
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";

interface MemberProfileProps {
  memberId: string;
  libraryId: string;
  canEdit: boolean;
}

export function MemberProfile({ memberId, libraryId, canEdit }: MemberProfileProps) {
  const { data: member, isLoading } = useQuery({
    queryKey: ["member-profile", memberId, libraryId],
    queryFn: () => fetchMemberProfile(memberId, libraryId),
  });

  const { data: checkouts } = useQuery({
    queryKey: ["member-checkouts", memberId, libraryId],
    queryFn: () => fetchMemberActiveCheckouts(memberId, libraryId),
  });

  // Profile display with conditional edit interface
}

// src/components/members/add-member-form.tsx
interface AddMemberFormProps {
  libraryId: string;
  onSuccess: (member: LibraryMember) => void;
}

export function AddMemberForm({ libraryId, onSuccess }: AddMemberFormProps) {
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<MemberRegistrationData>({
    resolver: zodResolver(memberRegistrationSchema),
  });

  const mutation = useMutation({
    mutationFn: (data: MemberRegistrationData) => createMember(data, libraryId),
    onSuccess: (newMember) => {
      queryClient.invalidateQueries({ queryKey: ["members", libraryId] });
      onSuccess(newMember);
    },
  });

  // Form implementation with validation and duplicate checking
}
```

### **File Locations and Project Structure**

[Source: docs/architecture/source-tree.md]

**New Files to Create:**

- `src/app/[library-code]/members/page.tsx` - Member list page route with search
- `src/app/[library-code]/members/add/page.tsx` - Member registration page route
- `src/app/[library-code]/members/[id]/page.tsx` - Member profile page route  
- `src/app/[library-code]/members/[id]/edit/page.tsx` - Member edit page route
- `src/components/members/member-list.tsx` - Member list display component
- `src/components/members/member-profile.tsx` - Member profile display component
- `src/components/members/add-member-form.tsx` - Member registration form
- `src/components/members/edit-member-form.tsx` - Member edit form
- `src/components/members/member-search.tsx` - Search functionality component
- `src/lib/api/members.ts` - Member API functions and database operations
- `src/lib/hooks/use-members.ts` - Member data fetching and mutation hooks
- `src/lib/validation/members.ts` - Member validation schemas with Zod

**Import Path Pattern (MANDATORY):**

```typescript
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select } from "@/components/ui/select";
import { useMemberProfile } from "@/lib/hooks/use-members";
import { usePermissions } from "@/lib/hooks/use-permissions";
import { memberRegistrationSchema } from "@/lib/validation/members";
import type { LibraryMember } from "@/lib/types/members";
```

### **Role-Based Access Control Implementation**

[Source: docs/architecture/data-access-rules.md]

**Access Control Rules for Library Members:**

- **READ**: User owns membership OR staff of the library
- **EDIT**: Owner, manager, librarian roles for the library (volunteers cannot edit)
- **CREATE**: Owner, manager, librarian roles for the library (volunteers cannot create)
- **DELETE**: Soft delete only via EDIT permissions (owner, manager, librarian)

**Permission Check Implementation:**

```typescript
// Use existing library context for permission validation
const { library, staff } = useLibraryContext();
const { canManageMembers } = usePermissions();

// Role-based UI rendering
{canManageMembers() && (
  <Button asChild>
    <Link href={`/${library.code}/members/add`}>Add New Member</Link>
  </Button>
)}

// API permission enforcement
const canEditMember = hasMinimumRoleLevel('librarian');
if (!canEditMember) {
  throw new Error('Insufficient permissions to edit members');
}
```

### **Form Validation Schema**

```typescript
// src/lib/validation/members.ts
import { z } from "zod";

export const memberRegistrationSchema = z.object({
  first_name: z
    .string()
    .min(1, "First name is required")
    .max(50, "First name must be less than 50 characters"),
  last_name: z
    .string()
    .min(1, "Last name is required")
    .max(50, "Last name must be less than 50 characters"),
  email: z
    .string()
    .email("Please enter a valid email address")
    .max(100, "Email must be less than 100 characters"),
  phone: z
    .string()
    .regex(/^[\+]?[1-9][\d]{0,15}$/, "Please enter a valid phone number")
    .optional()
    .or(z.literal("")),
  address: z.object({
    street: z
      .string()
      .max(100, "Street address must be less than 100 characters")
      .optional(),
    city: z
      .string()
      .max(50, "City must be less than 50 characters")
      .optional(),
    state: z
      .string()
      .max(50, "State must be less than 50 characters")
      .optional(),
    country: z
      .string()
      .max(50, "Country must be less than 50 characters")
      .optional(),
    postal_code: z
      .string()
      .max(20, "Postal code must be less than 20 characters")
      .optional(),
  }).optional(),
  membership_type: z.enum(["regular", "student", "senior"]).default("regular"),
  notes: z
    .string()
    .max(500, "Notes must be less than 500 characters")
    .optional(),
});

export const memberUpdateSchema = memberRegistrationSchema.partial();
export type MemberRegistrationData = z.infer<typeof memberRegistrationSchema>;
export type MemberUpdateData = z.infer<typeof memberUpdateSchema>;
```

### **Library Context and RLS Integration**

[Source: Story 2.3 completion notes, library context patterns]

**Library-Scoped Operations:**

- All member operations must include `library_id` filter for RLS compliance
- Use existing library context from URL parameter `[library-code]`
- Permission validation scoped to current library only
- Member operations automatically include library association
- Staff permissions validated through existing authentication system

**Library Context Usage Pattern:**

```typescript
// In member management page components
export default function MembersPage({
  params,
}: {
  params: { "library-code": string };
}) {
  const { library, staff } = useLibraryContext();
  const { canManageMembers } = usePermissions();

  const { data: members } = useMembers(library.id);

  // Component implementation with library-scoped operations
}
```

### **Real-time Integration and Cache Management**

[Source: Story 2.3 patterns - TanStack Query integration]

**Query Invalidation Pattern:**

```typescript
// src/lib/hooks/use-members.ts
export function useMembers(libraryId: string, searchTerm?: string) {
  const queryClient = useQueryClient();

  const createMutation = useMutation({
    mutationFn: (data: MemberRegistrationData) => createMember(data, libraryId),
    onSuccess: (newMember) => {
      // Invalidate member list queries for immediate UI updates
      queryClient.invalidateQueries({ queryKey: ["members", libraryId] });
      queryClient.setQueryData(["member-profile", newMember.id], newMember);
      
      toast.success("Member registered successfully!");
    },
    onError: (error) => {
      toast.error(`Failed to register member: ${error.message}`);
    },
  });

  const updateMutation = useMutation({
    mutationFn: ({ memberId, data }: { memberId: string; data: MemberUpdateData }) => 
      updateMember(memberId, data, libraryId),
    onSuccess: (updatedMember) => {
      queryClient.invalidateQueries({ queryKey: ["members", libraryId] });
      queryClient.setQueryData(["member-profile", updatedMember.id], updatedMember);
      
      toast.success("Member updated successfully!");
    },
  });

  return { createMutation, updateMutation };
}
```

### **Testing Standards**

[Source: docs/architecture/coding-standards.md]

**Testing Framework:** Jest for unit tests, React Testing Library for component tests, Playwright for E2E tests

**Test File Locations:**

- Unit tests: `src/components/members/__tests__/add-member-form.test.tsx`
- Hook tests: `src/lib/hooks/__tests__/use-members.test.ts`
- API tests: `src/lib/api/__tests__/members.test.ts`
- Validation tests: `src/lib/validation/__tests__/members.test.ts`
- E2E tests: `tests/e2e/member-management.spec.ts`

**Required Test Cases:**

1. **Member Registration Tests**: Test form validation, duplicate email detection, automatic ID generation
2. **Member List Tests**: Test search functionality, pagination, and display of member information
3. **Member Profile Tests**: Test profile display, checkout information, and edit access controls
4. **Edit Form Tests**: Test field updates, email validation, and permission enforcement
5. **API Integration Tests**: Test member CRUD operations, RLS compliance, and error handling
6. **Library Context Tests**: Ensure operations are properly scoped to active library
7. **Real-time Update Tests**: Verify cache invalidation and UI refresh after member operations
8. **Mobile Responsiveness Tests**: Validate member management usability on different screen sizes

**Test Examples:**

```typescript
// Component test example
describe("AddMemberForm", () => {
  it("should register new member with valid information", async () => {
    const mockOnSuccess = jest.fn();
    render(<AddMemberForm libraryId="lib-123" onSuccess={mockOnSuccess} />);

    await user.type(screen.getByLabelText(/first name/i), 'John');
    await user.type(screen.getByLabelText(/last name/i), 'Doe');
    await user.type(screen.getByLabelText(/email/i), 'john.doe@example.com');
    await user.click(screen.getByRole('button', { name: /register member/i }));

    expect(mockOnSuccess).toHaveBeenCalledWith(
      expect.objectContaining({
        member_id: expect.stringMatching(/^M\d{3}$/),
        personal_info: {
          first_name: 'John',
          last_name: 'Doe',
          email: 'john.doe@example.com',
        },
        status: 'active',
      })
    );
  });

  it("should detect duplicate email addresses", async () => {
    render(<AddMemberForm libraryId="lib-123" onSuccess={jest.fn()} />);

    await user.type(screen.getByLabelText(/email/i), 'existing@example.com');
    await user.click(screen.getByRole('button', { name: /register member/i }));

    expect(screen.getByText(/email address already exists/i)).toBeInTheDocument();
  });

  it("should validate required fields", async () => {
    render(<AddMemberForm libraryId="lib-123" onSuccess={jest.fn()} />);

    await user.click(screen.getByRole('button', { name: /register member/i }));

    expect(screen.getByText(/first name is required/i)).toBeInTheDocument();
    expect(screen.getByText(/last name is required/i)).toBeInTheDocument();
    expect(screen.getByText(/please enter a valid email address/i)).toBeInTheDocument();
  });
});
```

## Change Log

| Date       | Version | Description                                                                 | Author     |
| ---------- | ------- | --------------------------------------------------------------------------- | ---------- |
| 2025-01-08 | 1.0     | Initial story creation with full context from Epic 2.4 requirements        | Bob (SM)   |

## Dev Agent Record

### Agent Model Used
*This section will be populated by the development agent during implementation*

### Debug Log References  
*This section will be populated by the development agent during implementation*

### Completion Notes List
*This section will be populated by the development agent during implementation*

### File List
*This section will be populated by the development agent during implementation*

## QA Results

*This section will be populated by QA Agent after story implementation review*