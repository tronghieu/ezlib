# Story 1.6: CI/CD Pipeline and Deployment Infrastructure

## Status

**PLANNED** - Ready for implementation after Story 1.2 completion

## Story

**As a** developer,  
**I want** to establish automated CI/CD pipeline with Vercel deployment and quality gates,  
**so that** code changes are automatically tested, validated, and deployed safely with proper environment management and rollback capabilities.

## Prerequisites

- ✅ **Story 1.1**: Project setup with Next.js structure
- ✅ **Story 1.2**: Supabase integration for health check validation

## Acceptance Criteria

### **AC1: GitHub Actions Workflow Configuration**

1. GitHub Actions workflow file (`.github/workflows/ci.yml`) created with proper triggers
2. Workflow triggers on push to `main` branch and pull requests
3. Node.js 20+ environment setup with PNPM package management
4. Proper caching strategy for dependencies and build artifacts
5. Workflow status badges integrated in README

### **AC2: Quality Gates Pipeline**

1. ESLint validation with zero warnings allowed for production
2. TypeScript strict mode compilation without errors
3. Unit tests execution with minimum 80% coverage threshold
4. Build validation ensuring production build succeeds
5. Bundle size analysis to prevent regression

### **AC3: Environment Variable Management**

1. Development environment variables from GitHub repository secrets
2. Production environment variables from Vercel environment settings
3. Supabase keys properly secured and injected at build time
4. Feature flags configuration for different environments
5. Environment validation before deployment

### **AC4: Vercel Deployment Configuration**

1. Vercel project setup for standalone Next.js application
2. Build command: `pnpm run build` configured
3. Output directory: `.next` properly set
4. Framework preset: Next.js with App Router
5. Serverless functions configuration for API routes

### **AC5: Environment Management Strategy**

1. Development previews from pull requests with auto-generated URLs
2. Staging environment at `staging.manage.ezlib.com` from main branch
3. Production environment at `manage.ezlib.com` with manual promotion
4. Environment-specific configurations properly isolated
5. Rollback capability to previous deployments

### **AC6: Deployment Safety & Monitoring**

1. Health check endpoint (`/api/health`) validates deployment success
2. Post-deployment validation ensures database connectivity
3. Automatic rollback triggers if health checks fail
4. Performance monitoring with Vercel Analytics enabled
5. Error tracking configured for production issues

## Implementation Tasks

### **Task 1: Create GitHub Actions Workflow** (AC1, AC2)

- [ ] Create `.github/workflows/ci.yml` file
- [ ] Configure workflow triggers and environment setup
- [ ] Set up PNPM with proper caching strategy
- [ ] Add quality gate steps (lint, type-check, test, build)
- [ ] Configure workflow status badges

### **Task 2: Configure Environment Variables** (AC3)

- [ ] Set up GitHub repository secrets for CI/CD
- [ ] Configure Vercel environment variables
- [ ] Create environment validation script
- [ ] Document required environment variables
- [ ] Test secret injection in build process

### **Task 3: Set Up Vercel Project** (AC4)

- [ ] Create Vercel project for library management app
- [ ] Configure build and output settings
- [ ] Set up custom domains with SSL certificates
- [ ] Configure serverless function settings
- [ ] Test deployment from GitHub integration

### **Task 4: Implement Environment Strategy** (AC5)

- [ ] Configure preview deployments for pull requests
- [ ] Set up staging environment with auto-deployment
- [ ] Configure production environment with manual promotion
- [ ] Implement rollback procedures
- [ ] Document deployment workflow

### **Task 5: Create Health Check Endpoint** (AC6)

- [ ] Implement `/api/health` route handler
- [ ] Add database connectivity check
- [ ] Include environment configuration validation
- [ ] Return proper HTTP status codes
- [ ] Test health check in deployment pipeline

### **Task 6: Set Up Monitoring & Alerts** (AC6)

- [ ] Enable Vercel Analytics for performance monitoring
- [ ] Configure error tracking for production
- [ ] Set up deployment notifications
- [ ] Create performance baseline metrics
- [ ] Document monitoring procedures

## Definition of Done

### **Technical Validation**

- [ ] GitHub Actions workflow successfully runs all quality gates
- [ ] Deployments work for all environments (preview, staging, production)
- [ ] Health check endpoint properly validates system status
- [ ] Rollback procedure tested and functional
- [ ] Performance monitoring actively collecting metrics

### **Security Requirements**

- [ ] All secrets properly secured in GitHub and Vercel
- [ ] No credentials exposed in logs or build artifacts
- [ ] HTTPS enforced on all environments
- [ ] Security headers properly configured
- [ ] Dependency vulnerability scanning active

### **Documentation Requirements**

- [ ] CI/CD pipeline documented in README
- [ ] Deployment procedures clearly outlined
- [ ] Environment variables documented in `.env.example`
- [ ] Rollback procedures documented
- [ ] Monitoring access documented for team

### **Quality Standards**

- [ ] Zero ESLint warnings in production builds
- [ ] TypeScript strict mode passing
- [ ] Test coverage meets 80% threshold
- [ ] Build time under 5 minutes
- [ ] Bundle size within acceptable limits

## Epic Dependencies Resolved

### **Enables Epic 1 Continuation:**

- ✅ **Story 1.3**: Authentication testing requires deployment pipeline
- ✅ **Story 1.4**: Library context validation needs deployed environment
- ✅ **Story 1.5**: Dashboard testing requires staging environment

### **Provides Foundation For:**

- Continuous deployment workflow
- Quality assurance automation
- Performance monitoring baseline
- Security scanning integration
- Team deployment confidence

## Dev Notes

### **GitHub Actions Workflow Example**

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  quality-gates:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v3
        with:
          version: 8

      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Lint
        run: pnpm run lint

      - name: Type check
        run: pnpm run type-check

      - name: Test with coverage
        run: pnpm run test:coverage

      - name: Build
        run: pnpm run build

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
```

### **Vercel Configuration**

```json
{
  "buildCommand": "pnpm run build",
  "outputDirectory": ".next",
  "devCommand": "pnpm run dev",
  "installCommand": "pnpm install",
  "framework": "nextjs",
  "regions": ["iad1"],
  "functions": {
    "app/api/health/route.ts": {
      "maxDuration": 10
    }
  },
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        },
        {
          "key": "Strict-Transport-Security",
          "value": "max-age=31536000; includeSubDomains"
        }
      ]
    }
  ]
}
```

### **Health Check Implementation**

```typescript
// app/api/health/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

export async function GET() {
  const startTime = Date.now();

  try {
    // Check database connectivity
    const supabase = createClient();
    const { error } = await supabase.from("libraries").select("count").single();

    const dbLatency = Date.now() - startTime;

    if (error) {
      return NextResponse.json(
        {
          status: "unhealthy",
          timestamp: new Date().toISOString(),
          services: {
            database: {
              status: "unhealthy",
              error: error.message,
            },
          },
        },
        { status: 503 }
      );
    }

    // Check environment configuration
    const requiredEnvVars = [
      "NEXT_PUBLIC_SUPABASE_URL",
      "NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY",
    ];

    const missingVars = requiredEnvVars.filter(
      (varName) => !process.env[varName]
    );

    if (missingVars.length > 0) {
      return NextResponse.json(
        {
          status: "unhealthy",
          timestamp: new Date().toISOString(),
          error: `Missing environment variables: ${missingVars.join(", ")}`,
        },
        { status: 503 }
      );
    }

    return NextResponse.json({
      status: "healthy",
      timestamp: new Date().toISOString(),
      version: process.env.NEXT_PUBLIC_APP_VERSION || "1.0.0",
      environment: process.env.NODE_ENV,
      services: {
        database: {
          status: "healthy",
          latency_ms: dbLatency,
        },
        application: {
          status: "healthy",
          node_version: process.version,
        },
      },
    });
  } catch (error) {
    return NextResponse.json(
      {
        status: "unhealthy",
        timestamp: new Date().toISOString(),
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 503 }
    );
  }
}
```

### **Deployment Strategy**

1. **Pull Request Workflow**:
   - Developer creates PR → CI runs → Preview deployment created
   - Review and testing on preview URL
   - Merge to main after approval

2. **Staging Deployment**:
   - Automatic deployment from main branch
   - Full integration testing environment
   - Performance validation

3. **Production Deployment**:
   - Manual promotion from staging
   - Health check validation
   - Rollback if issues detected

### **Security Considerations**

- Use GitHub Secrets for sensitive values
- Implement secret scanning in CI pipeline
- Regular dependency updates with Dependabot
- Security headers on all responses
- HTTPS enforcement on all environments

### **Performance Monitoring**

- Vercel Analytics for Core Web Vitals
- Bundle size tracking with size-limit
- Lighthouse CI for performance regression
- Database query performance monitoring
- Real User Monitoring (RUM) data collection

## Change Log

| Date       | Version | Description                                    | Author     |
| ---------- | ------- | ---------------------------------------------- | ---------- |
| 2025-08-28 | 1.0     | Created story with standalone deployment focus | Sarah (PO) |

## QA Validation Checklist

### **CI/CD Pipeline Testing**

- [ ] GitHub Actions workflow triggers on appropriate events
- [ ] All quality gates pass for valid code
- [ ] Failed quality gates properly block deployment
- [ ] Caching improves build performance
- [ ] Workflow badges display correct status

### **Deployment Testing**

- [ ] Preview deployments created for pull requests
- [ ] Staging deployment updates automatically from main
- [ ] Production deployment requires manual promotion
- [ ] Custom domains resolve correctly with SSL
- [ ] Environment variables properly injected

### **Health Check Testing**

- [ ] Health endpoint returns proper status codes
- [ ] Database connectivity properly validated
- [ ] Environment configuration checked
- [ ] Response includes all required information
- [ ] Unhealthy status triggers appropriate alerts

### **Rollback Testing**

- [ ] Rollback to previous version works correctly
- [ ] Database state remains consistent after rollback
- [ ] User sessions maintained during rollback
- [ ] Rollback completes within acceptable timeframe
- [ ] Post-rollback health checks pass

### **Security Testing**

- [ ] No secrets exposed in logs or artifacts
- [ ] Security headers present on all responses
- [ ] HTTPS properly enforced
- [ ] Dependency vulnerabilities detected
- [ ] Access controls properly configured
